# Product: Corelight
# Category: NDR
# Supported Format: JSON
# Reference: See below
# Last Updated: 2021-06-30
# Copyright 2021 Chronicle LLC

# explictly supported_types:
    # capture_loss.log
    # conn.log
    # dce_rpc.log
    # dhcp.log
    # dpd.log
    # dns.log
    # files.log
    # http.log
    # kerberos.log
    # mysql.log
    # ntlm.log
    # ntp.log
    # radius.log
    # rdp.log
    # pe.log
    # sip.log
    # smtp.log
    # snmp.log
    # smb_files.log
    # smb_mapping.log
    # software.log
    # ssh.log
    # ssl.log
    # stats.log
    # syslog.log
    # tunnel.log
    # weird_stats.log
    # weird.log
    # x509.log
    # suricata
    # suricata_eve
# everything else will hit a generic catch-all


filter {

  # UDM > Metadata
  # - set default values
  mutate {
    replace => {
      "metadata_vendor_name"        => "Corelight"
      "metadata_product_name"       => "Zeek"
      "metadata_event_type"         => "GENERIC_EVENT"
    }
  }

  # UDM > Principal
  # - initialize non-string fields
  mutate {
    replace => {
      "principal_ip"           => ""
      "principal_port"         => ""
    }
  }

  # UDM > Target
  # - initialize required non-string fields
  mutate {
    replace => {
      "target_ip"              => ""
      "target_port"            => ""
    }
  }

  # Initialize log source specific fields that are needed for conditional or convert operations
  mutate {
    replace => {
      "query"                        => "" #dns
      "service"                      => "" #conn
      "uid"                          => "" #network
      "fuid"                         => "" #file
      "status_code"                  => "" #http
      "local_orig"                   => "true"  #network
      "method"                       => "" #http
      "response_code"                => "" #http
      "conn_uids.0"                  => "" #files
      "dns_answer"                   => "" #empty dns_answer
      "version"                      => "" #ssl
      "cipher"                       => "" #ssl
      "next_protocol"                => "" #ssl
      "server_name"                  => "" #ssl
      "certificate.not_valid_before" => "" #x509
      "certificate.not_valid_after"  => "" #x509
      "username"                     => "" #radius
      "extracted_cutoff"             => "" #files
      "mac"                          => "" #radius
      "auth_success"                 => "" #ssh
    }
    convert => {
      "local_orig" => "boolean"
      "is_orig"    => "boolean"
    }
  }

  # Fields that only exist when an optional package is loaded
  mutate {
    replace => {
      "icann_domain"                => "" #icannTLD
    }
  }


  # remove syslog header
  # - if using JSON over Syslog
  grok {
    match     => { "message" => [ "(?P<message>\{.*\})$" ] }
    on_error  => "_grok_not_syslog"
    overwrite => [ "message" ]
  }

  # Parse JSON log
  json {
    on_error       => "not_json"
    source         => "message"
    array_function => "split_columns"
  }

  if [not_json] {
    drop{}
  }

  if [_path] == "etc_viz" {
    mutate { replace => {"ts" => "%{_write_ts}"} on_error => "_timestamp_not_set"}

    if [_timestamp_not_set] {
      drop{ tag => "TAG_MALFORMED_MESSAGE" }
    }
  }

  # Parse date.
  # - Corelight TS format "2020-06-25T19:56:45.033699Z"
  date {
    match => ["ts", "RFC3339" ]
    on_error => "_ts_not_found"
  }

  # Convert field formats to required type
  mutate { convert => { "id.orig_p" => "string" } }
  mutate { convert => { "id.resp_p" => "string" } }
  mutate { uppercase => [ "proto" ] }


  # ----------------------------------------------------------------------
  # GLOBAL ASSIGNMENTS
  # - fields included in every zeek type of log

  # UDM > Metadata > Product Log ID
  # - Zeek includes a UID for a network transaction, we want to stich and group on this first
  # - for logs that include a FUID, e.g., Files, capture the CONN_UID over FUID
  # - fall back to FUID (shouldn't ever need this this scenario?)
  # - and finally, for logs with none of the above, try ID, e.g., x509
  if [uid] != "" {
    mutate { replace => { "metadata_product_log_id" => "%{uid}" } }
  } else if [conn_uids][0] != "" {
    mutate { replace => { "metadata_product_log_id" => "%{conn_uids.0}" } }
  } else if [fuid] != "" {
    mutate { replace => { "metadata_product_log_id" => "%{fuid}" } }
  }

  # UDM > Metadata > Product Event Type
  mutate {
    replace => { "metadata_product_event_type" => "%{_path}" }
  }

  # UDM > Observer > Hostname
  # - the Corelight sensor itself
  mutate {
      replace => { "observer_hostname" => "%{_system_name}" }
      on_error => "_ex"
  }

  # UDM > Principal > IP
  mutate {
    replace => { "principal_ip"   => "%{id.orig_h}" }
    on_error => "_field_not_set"
  }

  # UDM > Principal > Port
  mutate {
    replace => { "principal_port" => "%{id.orig_p}" }
    on_error => "_field_not_set"
  }

  # UDM > Target > IP
  mutate {
    replace => { "target_ip"      => "%{id.resp_h}" }
    on_error => "_field_not_set"
  }

  # UDM > Target > Port
  mutate {
    replace => { "target_port"    => "%{id.resp_p}" }
    on_error => "_field_not_set"
  }

  # ----------------------------------------------------------------------
  # DNS
  # - tracks and logs DNS queries along with their responses
  # - https://docs.corelight.com/docs/sensor/reference/logs/dns.html
  # - https://docs.corelight.com/docs/sensor/reference/logs/dns_red.html

  if [_path] == "dns" or [_path] == "dns_red" {

    # occasional DNS logs include no question, we drop them as they have no pratical usage
    if [query] == "" {
      drop{}
    }

    # UDM > Metadata > Event Type
    mutate {
      replace => { "metadata_event_type"   => "NETWORK_DNS" }
    }

    # UDM > Network > Application Protocol
    mutate {
      replace => { "network_application_protocol" => "DNS" }
    }

    # UDM > Network > IP Protocol
    mutate {
      replace => { "network_ip_protocol" => "%{proto}" }
      on_error => "_field_not_set"
    }

    # UDM > Metadata > Description
    mutate {
      replace => { "metadata_description" => "%{qclass_name}" }
      on_error => "_field_does_not_exist"
    }

    # UDM > Network > DNS_Name
    if [icann_domain] != "" {
      mutate {
        # rename => { "icann_domain" => "event1.idm.read_only_udm.network.dns_domain" }
        replace => { "event1.idm.read_only_udm.network.dns_domain" => "%{icann_domain}"}
      }
    }

    # UDM > Network > DNS
    mutate {
      rename => { "AA" => "dns.authoritative" }
    }
    mutate {
      rename => { "TC" => "dns.truncated" }
    }
    mutate {
      rename => { "RD" => "dns.recursion_desired" }
    }
    mutate {
      rename => { "RA" => "dns.recursion_available" }
    }

    mutate {
      rename => {
        "dns" => "event1.idm.read_only_udm.network.dns"
      }
    }

    # UDM > Network > DNS > Answer > Name
    mutate {
      replace => { "dns_answer.name" => "%{answers.0}" }
      on_error => "_field_does_not_exist"
    }

    mutate {
      rename => { "dns_answer_name" => "dns_answer.name" }
      on_error => "_field_does_not_exist"
    }

    # UDM > Network > DNS > Answer > Response Code
    mutate {
      convert => { "rcode" => "uinteger" }
      on_error => "_grok_not_rcode"
    }

    if ![_grok_not_rcode] {
      mutate {
        rename => { "rcode" => "network_dns_response_code" }
      }
    }

    # UDM > Network > DNS > Question > Answer (Merge)
    if [dns_answer] != "" {
      mutate {
        merge => {
          "event1.idm.read_only_udm.network.dns.answers" = "dns_answer"
        }
      }
    }

    # UDM > Network > DNS > Question > Name
    mutate {
      replace => { "dns_question.name" => "%{query}" }
      on_error => "_field_not_set"
    }

    # UDM > Network > DNS > Question > Class
    mutate {
       convert => { "qclass" => "uinteger" }
       on_error => "_convert_qclass_failed"
    }

    if ![_convert_qclass_failed] {
      mutate {
         rename => { "qclass" => "dns_question.class" }
         on_error => "_field_not_set"
      }
    }

     # UDM > Network > DNS > Question > Type
    mutate {
      convert => { "qtype" => "uinteger" }
      on_error => "_convert_qtype_failed"
    }

    if ![_convert_qtype_failed] {
      mutate {
        rename => { "qtype" => "dns_question.type" }
        on_error => "_field_not_set"
      }
    }

    # UDM > Network > DNS > Questions (Merge)
    mutate {
      merge => { "event1.idm.read_only_udm.network.dns.questions" => "dns_question" }
    }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }
  }
  #

  # ----------------------------------------------------------------------
  # CONN
  # - tracking/logging of general information regarding TCP, UDP, and ICMP traffic.
  # - For UDP and ICMP, connections are to be interpreted using flow semantics (sequence of packets from a source host/port to a destination host/port).
  # - Further, ICMP “ports” are to be interpreted as the source port meaning the ICMP message type and the destination port being the ICMP message code.
  # - https://docs.corelight.com/docs/sensor/reference/logs/conn.html
  # - https://docs.corelight.com/docs/sensor/reference/logs/conn_red.html
  # - https://docs.corelight.com/docs/sensor/reference/logs/conn_long.html

  if [_path] == "conn" or [_path] == "conn_red" or [_path] == "conn_long"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_CONNECTION" } }

    # UDM > Metadata > Description
    mutate {
      replace => { "metadata_description"  => "%{conn_state}" }
      on_error => "_field_not_set"
    }

    # UDM > Network > IP Protocol
    mutate {
      replace => { "network_ip_protocol" => "%{proto}" }
      on_error => "_field_not_set"
    }

    if [conn_state] == "S0" {
      mutate {
        replace => { "metadata_description" => "%{metadata_description}: Connection attempt seen, no reply" }
      }
    } else if [conn_state] == "S1" {
      mutate {
        replace => { "metadata_description" => "%{metadata_description}: Connection established, not terminated" }
      }
    } else if [conn_state] == "S2" {
      mutate {
        replace => { "metadata_description" => "%{metadata_description}: Connection established and close attempt by originator seen (but no reply from responder)" }
      }
    } else if [conn_state] == "S3" {
      mutate {
        replace => { "metadata_description" => "%{metadata_description}: Connection established and close attempt by responder seen (but no reply from originator)" }
      }
    }  else if [conn_state] == "SF" {
      mutate {
        replace => { "metadata_description" => "%{metadata_description}: Normal SYN/FIN completion" }
      }
    } else if [conn_state] == "REJ" {
      mutate {
        replace => { "metadata_description" => "%{metadata_description}: Connection attempt rejected" }
      }
    } else if [conn_state] == "RSTO" {
      mutate {
        replace => { "metadata_description" => "%{metadata_description}: Connection established, originator aborted (sent a RST)" }
      }
    } else if [conn_state] == "RSTOS0" {
      mutate {
        replace => { "metadata_description" => "%{metadata_description}: Originator sent a SYN followed by a RST, we never saw a SYN-ACK from the responder" }
      }
    } else if [conn_state] == "RSTOSH" {
      mutate {
        replace => { "metadata_description" => "%{metadata_description}: Responder sent a SYN ACK followed by a RST, we never saw a SYN from the (purported) originator" }
      }
    } else if [conn_state] == "RSTR" {
      mutate {
        replace => { "metadata_description" => "%{metadata_description}: Established, responder aborted" }
      }
    } else if [conn_state] == "SH" {
      mutate {
        replace => { "metadata_description" => "%{metadata_description}: Originator sent a SYN followed by a FIN, we never saw a SYN ACK from the responder (hence the connection was “half” open)" }
      }
    } else if [conn_state] == "SHR" {
      mutate {
        replace => { "metadata_description" => "%{metadata_description}: Responder sent a SYN ACK followed by a FIN, we never saw a SYN from the originator" }
      }
    } else if [conn_state] == "OTH" {
      mutate {
        replace => { "metadata_description" => "%{metadata_description}: No SYN seen, just midstream traffic (a partial connection that was not later closed)" }
      }
    }

    # UDM > Princip & Target > IPs (switched to account for origin)
    # - we already set IP principal & target ports in gloabl declaration, if inverse direction we switch below
    # - "If the connection is originated locally, this value will be T."
    # - "If it was originated remotely it will be F."
    # - "In the case that the Site::local_nets variable is undefined, this field will be left empty at all times."
    if ![local_orig] {
      mutate {
        replace => {
          "principal_ip"   => "%{id.orig_h}"
          "principal_port" => "%{id.orig_p}"
          "target_ip"      => "%{id.resp_h}"
          "target_port"    => "%{id.resp_p}"
        }
      }
    }

    # UDM > Network > Received Bytes
    mutate {
      convert => { "resp_bytes" => "uinteger" }
      on_error => "_resp_bytes_not_set"
    }

    if ![_resp_bytes_not_set] {
      mutate { rename => { "resp_bytes" => "network_received_bytes" }
      }
    }

    # UDM > Network > Sent Bytes
    mutate {
      convert => { "orig_bytes" => "uinteger" }
      on_error => "_orig_bytes_not_set"
    }

    if ![_orig_bytes_not_set] {
      mutate { rename => { "orig_bytes" => "network_sent_bytes" }
      }
    }

    # UDM > Network > Community ID
    mutate {
      replace => {
        "event1.idm.read_only_udm.network.community_id" => "%{community_id}"
      }
      on_error => "_field_not_set"
    }

    # UDM > Network > Application Protocol
    mutate {
      uppercase => [ "service" ]
    }

    if [service] != "" and [service] in ["AFP", "AFPC", "APPC", "AQMP", "ATOM", "BEEP", "BITCOIN", "BIT_TORRENT", "CFDP", "COAP", "DDS", "DEVICE_NET", "DHCP", "DNS", "E_DONKEY", "ENRP", "FAST_TRACK", "FINGER", "FREENET", "FTAM", "GOPHER", "HL7", "H323", "HTTP", "HTTPS", "IRCP", "KADEMLIA", "LDAP", "LPD", "MIME", "MODBUS", "MQTT", "NETCONF", "NFS", "NIS", "NNTP", "NTCIP", "NTP", "OSCAR", "PNRP", "QUIC", "RDP", "RELP", "RIP", "RLOGIN", "RPC", "RTMP", "RTP", "RTPS", "RTSP", "SAP", "SDP", "SIP", "SLP", "SMB", "SMTP", "SNTP", "SSH", "SSMS", "STYX", "TCAP", "TDS", "TOR", "TSP", "VTP", "WHOIS", "", "WEB_DAV", "X400", "X500", "XMPP" ] {
      if [service] == "SSL" {
        if ([target_port] == "443" or [principal_port] == "443") {
          mutate { replace => { "service" => "HTTPS" }}
          mutate {
            rename => { "service" => "network_application_protocol" }
              on_error => "_unsupported_app_protocol"
            }
          }
          mutate { replace => { "is_ssl" => "true" }}
          mutate { convert => { "is_ssl" => "boolean"}}
          mutate { rename => { "is_ssl" => "event1.idm.read_only_udm.network.tls.established"}}
      } else {
          mutate {
            rename => { "service" => "network_application_protocol" }
              on_error => "_unsupported_app_protocol"
            }
      }
    }else if [service] != ""{
      mutate {
        rename => { "service" => "about.application" }
          on_error => "_application_not_set"
      }
    }


    # UDM > Security Results
    mutate {
      replace => {
        "security_result.description" => "%{metadata_description}"
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }

  }
  #

  # ----------------------------------------------------------------------
  # x509
  # - https://docs.corelight.com/docs/sensor/reference/logs/x509.html
  # - https://docs.corelight.com/docs/sensor/reference/logs/x509_red.html

  if [_path] == "x509" or [_path] == "x509_red" {

    mutate { replace => { "metadata_event_type" => "GENERIC_EVENT" } }

    mutate { replace => { "metadata_product_log_id" => "%{fingerprint}" } }

    mutate {
      convert => {
        "certificate.version"          => "string"
      }
    }

    mutate {
      replace => {
       "event1.idm.read_only_udm.network.tls.server.certificate.version"      => "%{certificate.version}"
        "event1.idm.read_only_udm.network.tls.server.certificate.serial"      => "%{certificate.serial}"
        "event1.idm.read_only_udm.network.tls.server.certificate.subject"     => "%{certificate.subject}"
        "event1.idm.read_only_udm.network.tls.server.certificate.issuer"      => "%{certificate.issuer}"
        "event1.idm.read_only_udm.target.application"                         => "x509"
      }
    }

    # UDM > Network > TLS > Server
    if [certificate][not_valid_before] != "" {
      grok {
        match => { "certificate.not_valid_before" => [ "(?P<ts1>.*?)T(?P<ts2>\\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\d).*" ] }
        on_error => "_grok_not_before"
      }
    }

    if [certificate][not_valid_before] != "" {
      mutate {
        replace => {
          "ts3" => "%{ts1} %{ts2}"
        }
      }
    }

    if [certificate][not_valid_before] != "" {
      date {
        match => [ "ts3", "yyyy-MM-dd HH:mm:ss.SSS"]
        target => "event1.idm.read_only_udm.network.tls.server.certificate.not_before"
      }
    }


    if [certificate][not_valid_after] != "" {
      grok {
        match => { "certificate.not_valid_after" => [ "(?P<ts4>.*?)T(?P<ts5>\\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\d).*" ] }
        on_error => "_grok_not_after"
      }
    }

    if [certificate][not_valid_after] != "" {
      mutate {
        replace => {
          "ts6" => "%{ts4} %{ts5}"
        }
      }
    }

    if [certificate][not_valid_after] != "" {
      date {
        match => [ "ts6", "yyyy-MM-dd HH:mm:ss.SSS"]
        target => "event1.idm.read_only_udm.network.tls.server.certificate.not_after"
      }
    }

    # UDM > Security Results
    mutate {
      replace => {
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }

  }

  # ----------------------------------------------------------------------
  # FILES
  # - https://docs.corelight.com/docs/sensor/reference/logs/files.html
  # - https://docs.corelight.com/docs/sensor/reference/logs/files_red.html

  if [_path] == "files" or [_path] == "files_red"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type" => "FILE_UNCATEGORIZED" } }

   # UDM > Principal > Hostname (udm validation hack)
   # - as there is no hostname in the log, we populate IP address in brackets to pass udm validation for type of FILE_
    mutate {
      replace => { "principal_hostname" => "[%{tx_hosts.0}]" }
      on_error => "_field_not_found"
    }

    # UDM > Principal > IP
    mutate {
      replace => { "principal_ip" => "%{tx_hosts.0}" }
      on_error => "_field_not_found"
    }

    # UDM > Target > IP
    mutate {
      replace => { "target_ip"    => "%{rx_hosts.0}" }
      on_error => "_field_not_found"
    }

    # UDM > Target > File > MD5
    mutate {
      replace => { "target_file_md5"  => "%{md5}" }
      on_error => "_field_not_found"
    }

    # UDM > Target > File > SHA1
    mutate {
      replace => { "target_file_sha1" => "%{sha1}" }
      on_error => "_field_not_found"
    }

    # UDM > Target > File > SHA256
    mutate {
      replace => { "target_file_sha256" => "%{sha256}" }
      on_error => "_field_not_found"
    }

    # UDM > Target > File > Full Path
    mutate {
      replace => { "target_file_full_path"    => "%{filename}" }
      on_error => "_filename_field_not_found"
    }

    # - to pass udm validation full_path must be populated, but often there is no filename
    # - so to avoid dropping the log, add null, i.e., keep hash based info
    if [_filename_field_not_found] {
      mutate { replace => { "target_file_full_path" => "null" } }
      #drop{}
    }

    # UDM > Target > Mime Type
    mutate {
      replace => { "target_file_mime_type" => "%{mime_type}" }
      on_error => "_field_not_found"
    }

    # UDM > Target > File > File Size
    mutate {
      rename => {  "seen_bytes" => "target_file_size" }
      on_error => "_field_not_found"
    }

    # - file extraction information are parsed under About object
    # UDM > About > File > Full Path
    mutate {
      replace => { "about.file.full_path"    => "%{extracted}" }
      on_error => "_filename_field_not_found"
    }

  }
  #

  # ----------------------------------------------------------------------
  # DHCP
  # - https://docs.corelight.com/docs/sensor/reference/logs/dhcp.html

  if [_path] == "dhcp"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type" => "NETWORK_DHCP" } }

    # UDM > Network > Application Protocol
    mutate {
      replace => { "network_application_protocol" => "DHCP" }
    }

    # UDM > Metadata > Description
    mutate {
      replace => {  "metadata_description" => "%{msg_types.0}" }
      on_error => "_field_not_found"
    }

    # UDM > Network > DHCP Type
    mutate {
      replace => {  "network_dhcp_type" => "%{msg_types.0}" }
      on_error => "_field_not_found"
    }

    # UDM > Network > Opcode
    # - can be BOOTREPLY or BOOTREQUEST
    mutate {
      replace => {  "network_dhcp_opcode" => "BOOTREPLY" }
      on_error => "_field_not_found"
    }


    # UDM > Network > DHCP > yiaddr (your ip address)
    mutate {
      replace => {  "network_dhcp_yiaddr" => "%{client_addr}" }
      on_error => "_field_not_found"
    }

    # UDM > Network > DHCP > client_hostname (client hostname)
    mutate {
      replace => {  "network_dhcp_client_hostname" => "%{host_name}" }
      on_error => "_field_not_found"
    }

    # UDM > Network > DHCP > chaddr (client hardware address)
    mutate {
      replace => {  "network_dhcp_chaddr" => "%{mac}" }
      on_error => "_field_not_found"
    }

    # UDM > Network > DHCP > lease time seconds
    mutate {
      convert => { "lease_time" => "uinteger" }
      on_error => "_convert_lease_time_error"
    }

    if ![_convert_lease_time_error] {
      mutate {
        rename => { "lease_time" => "network_dhcp_lease_time_seconds" }
        on_error => "_field_not_found"
      }
    }

    # UDM > Principal > IP
    mutate {
      replace => { "principal_ip"  => "%{client_addr}" }
      on_error => "_field_not_found"
    }

    # UDM > Principal > MAC
    mutate {
      replace => { "principal_mac"  => "%{mac}" }
      on_error => "_field_not_found"
    }

  }
  #

  # ----------------------------------------------------------------------
  # CAPTURE LOSS
  # - https://docs.zeek.org/en/current/scripts/policy/misc/capture-loss.zeek.html

  if [_path] == "capture_loss"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type" => "STATUS_UPDATE" } }

    # UDM > Principal > Hostname (udm validation hack)
    # - no hostname present, use sensor name
    mutate {
      replace => { "principal_hostname" => "%{_system_name}" }
      on_error => "_field_not_set"
    }

    # UDM > Metadata > Description
    mutate {
      convert => { "percent_lost" => "string" }
      on_error => "not_packet_loss"
    }

    mutate {
      replace => {
         "metadata_description" => "node %{_system_name} experienced %{percent_lost}% packet loss at %{ts}"
      }
      on_error => "_field_not_set"
    }

    # UDM > Alert
    # - packet capture loss could result in missed security telemetry, off by default but can be changed for envs where not expected
    mutate {
      replace => {
        "is_significant" => "false"
        "is_alert"       => "false"
      }
    }

    mutate {
      convert => {
        "is_significant" => "boolean"
        "is_alert"       => "boolean"
      }
    }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.summary"     => "capture loss"
        "security_result.description" => "node %{_system_name} experienced %{percent_lost}% packet loss at %{ts}"
        "security_result.severity"    => "ERROR"
        "sr_action"                   => "ALLOW"
      }
      on_error => "_field_not_set"
    }

  }

  # ----------------------------------------------------------------------
  # CORELIGHT OVERALL PACKET LOSS

  if [_path] == "corelight_overall_capture_loss"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type" => "STATUS_UPDATE" } }

    # UDM > Principal > Hostname (udm validation hack)
    mutate {
      replace => { "principal_hostname" => "%{_system_name}" }
      on_error => "_field_not_set"
    }

    # UDM > Metadata > Description
    mutate {
      convert => { "percent_lost" => "string" }
      on_error => "not_packet_loss"
    }

    mutate {
      replace => { "metadata_description" => "node %{_system_name} experienced %{percent_lost}% packet loss at %{ts}" }
      on_error => "_field_not_set"
    }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.summary"     => "capture loss"
        "security_result.description" => "node %{_system_name} experienced %{percent_lost}% packet loss at %{ts}"
        "security_result.severity"    => "ERROR"
        "sr_action"                   => "ALLOW"
      }
      on_error => "_field_not_set"
    }

  }
  #

  # ----------------------------------------------------------------------
  # RDP
  # - https://docs.zeek.org/en/current/scripts/base/protocols/rdp/main.zeek.html

  if [_path] == "rdp"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_CONNECTION" } }

    # UDM > Network > IP Protocol
    mutate { replace => { "network_ip_protocol" => "TCP" } }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.description" => "%{result} connection with security protocol %{security_protocol}"
        "security_result.severity"    => "INFORMATIONAL"
        "sr_action"                   => "ALLOW"
      }
      on_error => "_field_not_set"
    }

  }

  # ----------------------------------------------------------------------
  # SYSLOG
  # - https://docs.zeek.org/en/current/scripts/base/protocols/syslog/

  if [_path] == "syslog"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_CONNECTION" } }

    # UDM > Network > IP Protocol
    mutate { replace => { "network_ip_protocol" => "%{proto}" } }

    # UDM > About > Labels > Facility
    mutate {
      replace => { "labels_about_facility.value" => "%{facility}" }
      on_error => "_facility_field_not_set"
    }
    if ![_facility_field_not_set] {
      mutate {
        replace => { "labels_about_facility.key" => "facility" }
      }
    }

    mutate {
      merge => { "about.labels" => "labels_about_facility" }
      on_error => "_about_field_not_set"
    }

    # UDM > About > Labels > Severity
    mutate {
      replace => { "labels_about_severity.value" => "%{severity}" }
      on_error => "_severity_field_not_set"
    }
    if ![_severity_field_not_set] {
      mutate {
        replace => { "labels_about_severity.key" => "syslog_severity" }
      }
    }

    mutate {
      merge => { "about.labels" => "labels_about_severity" }
      on_error => "_about_field_not_set"
    }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }
    mutate {
      replace => { "security_result.description" => "%{message}" }
      on_error => "_message_field_not_set"
    }

  }

  # ----------------------------------------------------------------------
  # SSL
  # - https://docs.zeek.org/en/current/scripts/base/protocols/ssl/

  if [_path] == "ssl"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_CONNECTION" } }

    # UDM > Network > Application Protocol
    mutate { replace => { "network_application_protocol" => "HTTPS" } }

    # UDM > Network > IP Protocol
    mutate { replace => { "network_ip_protocol" => "TCP" } }

    # UDM > Target > Hostname
    mutate {
      replace => {
        "event1.idm.read_only_udm.target.hostname"            =>  "%{server_name}"
      }
    }

    # UDM > Network > TLS
    if [next_protocol] != "" {
      mutate {
        replace => {
          "event1.idm.read_only_udm.network.tls.next_protocol" => "%{next_protocol}"
        }
      }
    }

    mutate {
      replace => {
        "event1.idm.read_only_udm.network.tls.version"            => "%{version}"
        "event1.idm.read_only_udm.network.tls.cipher"             => "%{cipher}"
        "event1.idm.read_only_udm.network.tls.client.server_name" => "%{server_name}"
      }
    }

    mutate {
      rename => {
        "resumed"     => "event1.idm.read_only_udm.network.tls.resumed"
        "established" => "event1.idm.read_only_udm.network.tls.established"
        "ja3"         => "event1.idm.read_only_udm.network.tls.client.ja3"
        "ja3s"        => "event1.idm.read_only_udm.network.tls.server.ja3s"
      }
    }


    # UDM > Security Results
    mutate {
      replace => {
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }


  }

  # ----------------------------------------------------------------------
  # NTP
  # - https://docs.zeek.org/en/current/scripts/base/protocols/ntp/main.zeek.html

  if [_path] == "ntp"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_CONNECTION" } }

    # UDM > Network > IP Protocol
    # - udm validation requires network field, so for now use ip protocol
    mutate { replace => { "network_ip_protocol" => "UDP" } }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }


  }

  # ----------------------------------------------------------------------
  # KERBEROS
  # - https://docs.zeek.org/en/current/scripts/base/protocols/krb/main.zeek.html

  if [_path] == "kerberos"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_CONNECTION" } }

    # UDM > Network > IP Procotocl
    mutate {
      replace => { "network_ip_protocol" => "TCP" }
    }

    # UDM > Target > Resource Type
    mutate {
      replace => { "target_resource_type" => "%{request_type}" }
      on_error => "_field_not_set"
    }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }


  }

  # ----------------------------------------------------------------------
  # SMB_FILES
  # - https://docs.zeek.org/en/current/scripts/base/protocols/smb/main.zeek.html

  if [_path] == "smb_files"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_CONNECTION" } }

    # UDM > Network > IP Protocol
    mutate { replace => { "network_ip_protocol" => "TCP" } }

    # UDM > Metadata > Description
    mutate {
      replace => { "metadata_description" => "action: %{action} on: %{name}" }
      on_error => "_field_not_set"
    }

    # UDM > Target > Resource Type
    mutate {
      replace => { "target_resource_type" => "FILE" }
      on_error => "_field_not_set"
    }

    # UDM > Target > File Size
    mutate {
      convert => { "size" => "uinteger" }
      on_error => "not_size"
    }

    if ![not_size] {
      mutate {
        rename => { "size" => "target_file_size" }
      }
    }

    # UDM > Target > File > Full Path
    mutate {
      replace => {
        "target_file_full_path" => "%{name}"
      }
      on_error => "_field_not_set"
    }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }

  }
  #

  # ----------------------------------------------------------------------
  # SMB_MAPPING
  # - https://docs.zeek.org/en/current/scripts/base/protocols/smb/main.zeek.html

  if [_path] == "smb_mapping"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_CONNECTION" } }

    # UDM > Network > IP Protocol
    mutate {
      replace => { "network_ip_protocol" => "TCP" }
    }

    # UDM > Target > Resource Type
    mutate {
      replace => { "target_resource_type" => "DISK" }
      on_error => "_field_not_set"
    }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }

  }


  # ----------------------------------------------------------------------
  # DCE_RPC
  # - https://docs.zeek.org/en/current/scripts/base/protocols/dce-rpc/main.zeek.html

  if [_path] == "dce_rpc"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_CONNECTION" } }

    # UDM > Network > IP Protocol
    mutate {
      replace => { "network_ip_protocol" => "TCP" }
    }

    # UDM > Metadata > Description
    mutate {
      replace => { "metadata_description" => "operation '%{operation}' on '%{endpoint}' at named pipe [%{named_pipe}] " }
      on_error => "_field_not_set"
    }

    # UDM > Target > Resrouce Type
    mutate {
      replace => { "target_resource_type" => "PIPE" }
      on_error => "_field_not_set"
    }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }


  }

  # ----------------------------------------------------------------------
  # STATS
  # - Log memory/packet/lag statistics
  # - https://docs.zeek.org/en/current/scripts/policy/misc/stats.zeek.html

  if [_path] == "stats"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "GENERIC_EVENT" } }

    # UDM > Principal > Hostname (udm validation hack)
    mutate {
      replace => { "principal_hostname" => "%{_system_name}" }
      on_error => "_field_not_set"
    }

    # UDM > Security Result
    mutate {
      replace => {
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }

  }
  #

  # ----------------------------------------------------------------------
  # WEIRD STATS
  # - Log weird statistics.
  # - https://docs.zeek.org/en/current/scripts/policy/misc/weird-stats.zeek.html

  if [_path] == "weird_stats"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "GENERIC_EVENT" } }

    # UDM > Metadata > Description
    mutate {
      replace => { "metadata_description" => "%{name}"
      on_error => "_weird_stats_field_not_set"
      }
    }

    # UDM > Security Result
    mutate {
      replace => {
        "security_result.description" => "%{name}"
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }

  }
  #

  # ----------------------------------------------------------------------
  # WEIRD
  # unusual or exceptional activity that can indicate malformed connections, traffic that doesn’t conform to a particular protocol, malfunctioning or misconfigured hardware, or even an attacker attempting to avoid/confuse a sensor
  # - https://docs.zeek.org/en/current/scripts/base/frameworks/notice/weird.zeek.html

  if [_path] == "weird"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "GENERIC_EVENT" } }

    # UDM > Metadata > Description
    mutate {
        replace => { "metadata_description" => "%{name}"
        on_error => "_field_not_set"
      }
    }

    # UDM > Target > Hostname (udm validation hack)
    # - log has no ip, use the Corelight sensor name as target
    if [principal_ip] == "" {
      mutate {
          replace => {
            "principal_hostname" => "%{_system_name}"
            "target_hostname" => "%{_system_name}"
          }
          on_error => "_field_not_set"
        }
    }

    # UDM > Alert
    # - notice is a configurable value in Corelight to specify if you should be notified
    if [notice] == "false" {
      mutate {
        replace => {
          "is_significant" => "false"
          "is_alert"       => "false"
        }
      }
    } else if [notice] == "true" {
      mutate {
        replace => {
          "is_significant" => "true"
          "is_alert"       => "true"
        }
      }
    }

    mutate {
      convert => {
        "is_significant" => "boolean"
        "is_alert"       => "boolean"
      }
    }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.description" => "%{name}"
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }

  }
  #

  # ----------------------------------------------------------------------
  # NOTICE
  # - things which are odd or potentially bad
  # - https://docs.zeek.org/en/current/scripts/base/frameworks/notice/main.zeek.html

  if [_path] == "notice"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "STATUS_UPDATE" } }

    # UDM > Metadata Description
    mutate {
      replace => {  "metadata_description" => "%{note}" }
      on_error => "_field_not_set"
    }

    # UDM > Principal > Hostname (udm validation hack)
    mutate {
      replace => { "principal_hostname" => "%{_system_name}" }
      on_error => "_field_not_set"
    }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.description" => "%{note}"
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }

  }

  # ----------------------------------------------------------------------
  # TUNNEL
  # - tracking/logging of tunnels (e.g. Teredo, AYIYA, or IP-in-IP such as 6to4 where “IP” is either IPv4 or IPv6).
  # - https://docs.zeek.org/en/current/scripts/base/frameworks/tunnels/main.zeek.html

  if [_path] == "tunnel" {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_HTTP" } }

    # UDM > Network > Application Protocol
    mutate {
      replace => { "network_application_protocol" => "HTTP" }
    }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.description" => "action %{action} on tunnel type %{tunnel_type} "
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }

  }
  #

  # ----------------------------------------------------------------------
  # DPD (Dynamic Protocol Detection)
  # - activates port-independent protocol detection and selectively disables analyzers if protocol violations occur
  # - https://docs.zeek.org/en/current/scripts/base/frameworks/dpd/

  if [_path] == "dpd" {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_CONNECTION" } }

    # UDM > Network > IP Protocol
    mutate { replace => { "network_ip_protocol" => "%{proto}" } }

    # UDM > Observer >  Application
    mutate { replace => { "observer_application" => "%{analyzer}" } }

    # UDM > Security Results
    mutate {
      replace => {
        "security_result.description" => "failure reason: %{failure_reason}"
        "security_result.severity" => "INFORMATIONAL"
        "sr_action" => "ALLOW"
      }
      on_error => "_field_not_set"
    }

  }
  #

  # ----------------------------------------------------------------------
  # MYSQL
  # - Implements base functionality for MySQL analysis. Generates the mysql.log file.
  # - https://docs.zeek.org/en/current/scripts/base/protocols/mysql/main.zeek.html

  if [_path] == "mysql" {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_UNCATEGORIZED" } }

    # UDM > Metadata > Description
    mutate { replace => { "metadata_description" => "%{cmd}" } }

    # UDM > Principal > Command Line
    mutate { replace => { "principal_process_cmd" => "%{arg}" } }

    # UDM > Security Results
    mutate {
      convert => { "rows" => "string" }
      on_error =>  "_rows_field_not_set"
    }
    if ![_rows_field_not_set] {
      mutate {
        replace => { "security_result.description" => "Affected rows: %{rows}" }
        on_error => "_conversion_error"
      }
    }

    mutate { replace => { "security_result.severity" => "INFORMATIONAL" } }

    if [success]{
      mutate {
       replace => {
         "security_result.summary" => "Query successfully executed"
         "sr_action" => "ALLOW"
       }
      }
    }
    else {
      mutate {
        replace => {
          "security_result.summary" => "Query execution failed"
          "sr_action" => "BLOCK"
        }
      }
    }
  }
  #

  # ----------------------------------------------------------------------
  # PE
  # - Provides information static analysis about executable files
  # - https://docs.zeek.org/en/current/scripts/base/files/pe/main.zeek.html

  if [_path] == "pe" {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "GENERIC_EVENT" } }

    # UDM > Metadata > Product Log ID
    mutate { replace => { "metadata_product_log_id" => "%{id}" } }

    # UDM > Target > Platform
    if [os] =~ /(?i)win/ {
      mutate { replace => { "target_platform" => "WINDOWS" } }
    } else if [os] =~ /(?i)linux/ {
      mutate { replace => { "target_platform" => "LINUX" } }
    } else if [os] =~ /(?i)mac/ or [os] =~ /(?i)osx/{
      mutate { replace => { "target_platform" => "MAC" } }
    }

    # UDM > Target > Platform Version
    mutate { replace => { "target_platform_version" => "%{os}" } }

    # UDM > Target > Resource > Resource Type
    mutate { replace => { "target_resource_type" => "DEVICE" } }

    # UDM > Target > Resource > Resource Subtype
    mutate {
      replace => { "target_resource_subtype" => "%{machine}" }
      on_error => "_field_not_set"
    }

    # UDM > Target > Application
    mutate {
      replace => { "target_application" => "%{subsystem}" }
      on_error => "_field_not_set"
    }

  }
  #

  # ----------------------------------------------------------------------
  # RADIUS
  # - RADIUS authentication attempts.
  # - https://docs.zeek.org/en/current/scripts/base/protocols/radius/main.zeek.html

  if [_path] == "radius" {

    # UDM > Metadata > Event Type
    if [username] == "" {
      mutate { replace => { "metadata_event_type"   => "NETWORK_UNCATEGORIZED" } }
    }
    else {
      mutate {
        replace => {
          "metadata_event_type"   => "USER_LOGIN"
          "extensions_auth_type" => "MACHINE"
        }
      }
    }

    # UDM > Principal > Username
    if [username] != "" {
      mutate { replace => { "principal_username"   => "%{username}" } }
    }

    # UDM > Principal > Mac
    if [mac] != "" {
      mutate { replace => { "principal_mac" => "%{mac}" } }
    }

    # UDM > Security Results
    if [result] == "success" {
      mutate {
        replace => {
          "sr_action" => "ALLOW"
          "security_result.summary" => "User login successful"
    }
      }
    }
    else if [result] == "failed" {
      mutate {
        replace => {
          "sr_action" => "BLOCK"
          "security_result.summary" => "User login failed"
        }
      }
    }

    mutate { replace => { "security_result.description" => "RADIUS authentication attempt: %{result}" } }
  }
  #

  # ----------------------------------------------------------------------
  # SIP
  # - Implements base functionality for SIP analysis. The logging model is to log request/response pairs and all relevant metadata together in a single record.
  # - https://docs.zeek.org/en/current/scripts/base/protocols/sip/main.zeek.html

  if [_path] == "sip" {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_UNCATEGORIZED" } }

    # UDM > Metadata > Description
    mutate {
      replace => { "metadata_description" => "%{method}" }
      on_error => "_field_not_set"
    }

    # UDM > Network > Application Protocol
    mutate { replace => { "network_application_protocol" => "SIP" } }

    # UDM > Network > Bytes
    mutate {
      convert => {"request_body_len" => "uinteger"}
      on_error => "_field_not_set"
    }
    mutate {
      convert => {"response_body_len" => "uinteger"}
      on_error => "_field_not_set"
    }

    mutate { rename => { "request_body_len" => "network_sent_bytes"  } }
    mutate { rename => { "response_body_len" => "network_received_bytes" } }

    # UDM > Network > Session ID
    mutate {
      replace => { "network_session_id" => "%{call_id}" }
      on_error => "_field_not_set"
    }

    # UDM > Principal > User ID
    grok {
      match => {
        "request_from" => [
          "^\\\"(?P<s_display_name>[^\\\\]*?)\\\"\\s*<(?P<s_sip_address>.*@.*\\.[a-zA-Z0-9]+):?.*?>$"
          "<(?P<s_sip_address>.*@.*\\.[a-zA-Z0-9]+):?.*?>"
        ]
      }
      on_error => "no_request_from"
    }

    if ![no_request_from]{
      mutate { replace => { "principal_username" => "%{s_sip_address}" } }
      mutate { rename => { "s_display_name" => "principal_user_display_name"}}
    }

    # UDM > Target > User ID
    grok {
      match => {
        "request_to" => [
          "^\\\"(?P<t_display_name>[^\\\\]*?)\\\"\\s*<(?P<t_sip_address>.*@.*\\.[a-zA-Z0-9]+):?.*?>$"
          "<(?P<t_sip_address>.*@.*\\.[a-zA-Z0-9]+):?.*?>"
        ]
      }
      on_error => "no_request_to"
    }

    if ![no_request_to]{
      mutate { replace => { "target_username" => "%{t_sip_address}" } }
      mutate { rename => { "t_display_name" => "target_user_display_name"}}
    }


    # UDM > About > URL
    mutate {
      replace => { "about.url" => "%{uri}" }
      on_error => "_uri_field_not_set"
    }

    # UDM > About > Labels > Subject
    mutate {
      replace => { "labels_about_subject.value" => "%{subject}" }
      on_error => "_subject_field_not_set"
    }
    if ![_subject_field_not_set] {
      mutate { replace => { "labels_about_subject.key" => "subject" } }
    }

    mutate { merge => { "about.labels" => "labels_about_subject" } on_error => "_about_field_not_set" }

    # UDM > Security Results
    mutate {
      convert => { "status_code" => "string" }
      on_error => "_status_code_not_set"
    }
    if ![_status_code_not_set] {
      mutate { replace => { "security_result.summary" => "Status Code: %{status_code}" } }
    }
    mutate {
      replace => { "security_result.description" => "%{status_msg}" }
      on_error => "_staatus_msg_not_set"
    }

    if [status_code] =~ /^4/ {
      mutate { replace => { "sr_action" => "BLOCK" } }
    }
    else if [status_code] =~ /^[23]/ {
      mutate { replace => { "sr_action" => "ALLOW" } }
    }
  }
  #

  # ----------------------------------------------------------------------
  # SMTP
  # - SMTP transaction.
  # - https://docs.zeek.org/en/current/scripts/base/protocols/smtp/main.zeek.html

  if [_path] == "smtp" {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_SMTP" } }

    # UDM > Network > Application Protocol
    mutate { replace => { "network_application_protocol"   => "SMTP" } }

    # UDM > Network > Email > From
    grok {
      match => { "from" => [
          ".*?\\s+<?(?P<email_from>[^\\s]*@.*\\.[a-zA-Z0-9]+)>?$"
          "<?(?P<email_from>.*@.*\\.[a-zA-Z0-9]+)>?$"
      ]}
      on_error => "_from_field_not_set"
    }

    mutate{ rename => { "email_from" => "network_email.from"} }

    # UDM > Network > Email > To
    grok {
      match => { "to.0" => [
          ".*?\\s+<?(?P<email_to>[^\\s]*@.*\\.[a-zA-Z0-9]+)>?$"
          "<?(?P<email_to>.*@.*\\.[a-zA-Z0-9]+)>?$"
      ]}
      on_error => "_to_field_not_set"
    }

    if ![_to_field_not_set] {
      mutate { merge => { "network_email.to" => "email_to"} }
    }

    # UDM > Network > Email > Cc
    grok {
      match => { "cc.0" => [
          ".*?\\s+<?(?P<email_cc>[^\\s]*@.*\\.[a-zA-Z0-9]+)>?$"
          "<?(?P<email_cc>.*@.*\\.[a-zA-Z0-9]+)>?$"
      ]}
      on_error => "_cc_field_not_set"
    }

    if ![_cc_field_not_set] {
      mutate { merge => { "network_email.cc" => "email_cc"} }
    }

    # UDM > Network > Email > Subject
    mutate {
      replace => { "email_subject"   => "%{subject}" }
      on_error => "_subject_field_not_set"
    }

    if ![_subject_field_not_set] {
      mutate { merge => { "network_email.subject" => "email_subject"} }
    }

    # UDM > Network > Email > Reply To
    grok {
      match => { "reply_to" => [
          ".*?\\s+<?(?P<email_reply_to>[^\\s]*@.*\\.[a-zA-Z0-9]+)>?$"
          "<?(?P<email_reply_to>.*@.*\\.[a-zA-Z0-9]+)>?$"
      ]}
      on_error => "_reply_to_field_not_set"
    }

    mutate{ rename => { "email_reply_to" => "network_email.reply_to"} }

    # UDM > Network > Email > Mail ID
    mutate {
      replace => { "network_email.mail_id"   => "%{msg_id}" }
      on_error => "_msg_id__field_not_set"
   }

   # UDM > Network > TLS > Established
   mutate {
    rename => {
      "tls" => "event1.idm.read_only_udm.network.tls.established"
      }
    }
  }

  # ----------------------------------------------------------------------
  # SNMP
  # - Enables analysis and logging of SNMP datagrams.
  # - https://docs.zeek.org/en/current/scripts/base/protocols/snmp/main.zeek.html

  if [_path] == "snmp" {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_UNCATEGORIZED" } }

    # UDM > Metadata > Product Version
    mutate {
      replace => { "metadata_product_version" => "SNMP %{version}" }
      on_error => "_field_not_found"
    }

    # UDM > Metadata > Description
    mutate {
      replace => { "metadata_description" => "%{display_string}" }
      on_error => "_field_not_found"
    }

    # UDM > Network > Session Duration
    mutate {
      convert => { "duration" => "integer" }
      on_error =>  "_not_duration"
    }
    mutate {
      rename => { "duration" => "network_session_duration" }
      on_error => "_conversion_error"
    }
  }

  # ----------------------------------------------------------------------
  # SOFTWARE
  # - Software observed on the network.
  # - https://docs.zeek.org/en/current/scripts/base/frameworks/software/main.zeek.html

  if [_path] == "software" {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "SCAN_UNCATEGORIZED" } }

    # UDM > Metadata > Url Back To Product
    mutate {
      replace => { "metadata_url_back_to_product" => "%{url}" }
      on_error => "_field_not_found"
    }

    # UDM > Principal > Ip
    mutate {
      replace => { "principal_ip" => "%{host}" }
      on_error => "_field_not_found"
    }

    # UDM > Principal > Port
    mutate {
      convert => { "host_p" => "string" }
      on_error =>  "_no_host_port_found"
    }
    mutate {
      replace => { "principal_port" => "%{host_p}" }
      on_error => "_conversion_error"
    }

    # UDM > Principal > Resource > Name
    mutate {
      replace => { "principal_resource_name" => "%{name}" }
      on_error => "_field_not_found"
    }

    # UDM > Principal > Resource > Resource Subtype
    mutate {
      replace => { "principal_resource_subtype" => "%{software_type}" }
      on_error => "_field_not_found"
    }

  }

  # ----------------------------------------------------------------------
  # SSH
  # - Implements base functionality for SSH analysis. Generates the ssh.log file.
  # - https://docs.zeek.org/en/current/scripts/base/protocols/ssh/main.zeek.html

  if [_path] == "ssh" {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_UNCATEGORIZED" } }

    # UDM > Metadata > Product Version
    mutate {
      replace => { "metadata_product_version" => "SSH %{version}" }
      on_error => "_field_not_found"
    }

    # UDM > Principal > Platform Version
    mutate {
      replace => { "principal_platform_version" => "%{client}" }
      on_error => "_field_not_found"
    }

    # UDM > Principal > HASSH
    mutate {
      replace => { "principal_process_md5" => "%{hassh}" }
      on_error => "_field_not_found"
    }

    # UDM > Target > Platform Version
    mutate {
      replace => { "target_platform_version" => "%{server}" }
      on_error => "_field_not_found"
    }
    # UDM > Target > HASSH
    mutate {
      replace => { "target_process_md5" => "%{hasshServer}" }
      on_error => "_field_not_found"
    }

    # UDM > Security Results
    mutate {
      convert => { "auth_attempts" => "string" }
      on_error =>  "_not_auth_attempts"
    }
    if [auth_success] != ""{
      mutate {
        replace => {
          "security_result.summary" => "SSH authentication success"
          "security_result.description" => "%{auth_attempts} successful SSH authentication attempts were observed"
          "sr_action" => "ALLOW"
        }
      }
    }
    else {
      mutate {
        replace => {
          "security_result.summary" => "SSH authentication failure"
          "security_result.description" => "%{auth_attempts} failed SSH authentication attempts were observed"
          "sr_action" => "BLOCK"
        }
      }
    }

    # UDM > Security Results > Description
    mutate {
      replace => { "code" => "%{inferences.0}"}
      on_error => "_inferences_not_found"
    }

    if ![_inferences_not_found] {
      if [code] == "ABP" {
        mutate { replace => {"sr.summary" => "Client Authentication Bypass" }}
        mutate { replace => {"sr.description" => "A client wasn't adhering to expectations of SSH either through server exploit or by the client and server switching to a protocol other than SSH after enctyption begins" }}
      }
      if [code] == "AFR" {
        mutate { replace => {"sr.summary" => "SSH Agent Forwarding Requested" }}
        mutate { replace => {"sr.description" => "Agent Forwarding is requested by tge Client" }}
      }
      if [code] == "APWA" {
        mutate { replace => {"sr.summary" => "Automated Password Authentication" }}
        mutate { replace => {"sr.description" => "The client authenticated with an automated password tool (like sshpass)" }}
      }
      if [code] == "AUTO" {
        mutate { replace => {"sr.summary" => "Automated Interaction" }}
        mutate { replace => {"sr.description" => "The client is a script automated utility and not driven by a user" }}
      }
      if [code] == "BAN" {
        mutate { replace => {"sr.summary" => "Server Banner" }}
        mutate { replace => {"sr.description" => "The server sent the client a pre-authentication banner, likely for legal reasons" }}
      }
      if [code] == "BF" {
        mutate { replace => {"sr.summary" => "Client Brute Force Guessing" }}
        mutate { replace => {"sr.description" => "A client made a number of authentication attempts that exceeded some configured, pre-connection threshold" }}
      }
      if [code] == "BFS" {
        mutate { replace => {"sr.summary" => "Client Brute Force Success" }}
        mutate { replace => {"sr.description" => "A client made a number of authentication attempts that exceeded some configured, pre-connection threshold" }}
      }
      if [code] == "CTS" {
        mutate { replace => {"sr.summary" => "Client Trusted Server" }}
        mutate { replace => {"sr.description" => "The client already has an entry in its known_hosts file for this server" }}
      }
      if [code] == "CUS" {
        mutate { replace => {"sr.summary" => "Client Untrusted Server" }}
        mutate { replace => {"sr.description" => "The client did not have an entry in its known_hosts file for this server" }}
      }
      if [code] == "IPWA" {
        mutate { replace => {"sr.summary" => "Interactive Password Authentication" }}
        mutate { replace => {"sr.description" => "The client interactively typed their password to authenticate" }}
      }
      if [code] == "KS" {
        mutate { replace => {"sr.summary" => "Keystrokes" }}
        mutate { replace => {"sr.description" => "An interactive session occurred in which the client set user-driven keystrokes to the server" }}
      }
      if [code] == "LFD" {
        mutate { replace => {"sr.summary" => "Large Client File Donwload" }}
        mutate { replace => {"sr.description" => "A file transfer occurred in which the server sent a sequence of bytes to the client" }}
      }
      if [code] == "LFU" {
        mutate { replace => {"sr.summary" => "Large Client File Upload" }}
        mutate { replace => {"sr.description" => "A file transfer occurred in which the client sent a sequence of bytes to the server. Large file are identified dynamically based on trains of MTU-sized packets" }}
      }
      if [code] == "MFA" {
        mutate { replace => {"sr.summary" => "Multifactor Authentication" }}
        mutate { replace => {"sr.description" => "The server required a second form of authentication (a code) after password or public key was accepted, and the client successfully provided it" }}
      }
      if [code] == "NA" {
        mutate { replace => {"sr.summary" => "None Authentication" }}
        mutate { replace => {"sr.description" => "The client successfully authenticated using the None method" }}
      }
      if [code] == "NRC" {
        mutate { replace => {"sr.summary" => "No Remote Command" }}
        mutate { replace => {"sr.description" => "The -N flag was used in SSH authentication" }}
      }
      if [code] == "PKA" {
        mutate { replace => {"sr.summary" => "Public Key Authentication" }}
        mutate { replace => {"sr.description" => "The client automatically authenticated using pubkey authentication" }}
      }
      if [code] == "RSI" {
        mutate { replace => {"sr.summary" => "Reverse SSH Initiated" }}
        mutate { replace => {"sr.description" => "The Reverse session is initiated from the server back to the client" }}
      }
      if [code] == "RSIA" {
        mutate { replace => {"sr.summary" => "Reverse SSH Initiated Automated" }}
        mutate { replace => {"sr.description" => "The inititation of the Reverse session happened very early in the packet stream, indicating automation" }}
      }
      if [code] == "RSK" {
        mutate { replace => {"sr.summary" => "Reverse SSH Keystrokes" }}
        mutate { replace => {"sr.description" => "Keystrokes are detected within the Reverse tunnel" }}
      }
      if [code] == "RSL" {
        mutate { replace => {"sr.summary" => "Reverse SSH Logged In" }}
        mutate { replace => {"sr.description" => "The Reverse Tunnel login has succeeded" }}
      }
      if [code] == "RSP" {
        mutate { replace => {"sr.summary" => "Reverse SSH Providioned" }}
        mutate { replace => {"sr.description" => "The client connected with -R flag, which provisions the port to be used for a Reverse Session set up at any future time" }}
      }
      if [code] == "SA" {
        mutate { replace => {"sr.summary" => "Authentication Scanning" }}
        mutate { replace => {"sr.description" => "The client scanned authentication method with the server and then disconnected" }}
      }
      if [code] == "SC" {
        mutate { replace => {"sr.summary" => "Capabilities Scanning" }}
        mutate { replace => {"sr.description" => "The client exchanged capabilities with the server and then disconnected" }}
      }
      if [code] == "SFD" {
        mutate { replace => {"sr.summary" => "Small Client File Download" }}
        mutate { replace => {"sr.description" => "A file transfer occurred in which the server sent a sequence of bytes to the client" }}
      }
      if [code] == "SFU" {
        mutate { replace => {"sr.summary" => "Small Client File Upload" }}
        mutate { replace => {"sr.description" => "A file transfer occurred in which the client sent a sequence of bytes to the server" }}
      }
      if [code] == "SP" {
        mutate { replace => {"sr.summary" => "Other Scanning" }}
        mutate { replace => {"sr.description" => "A client and server didn't exchange encrypted packets but the client wasn't a version or capabilities scanner" }}
      }
      if [code] == "SV" {
        mutate { replace => {"sr.summary" => "Version Scanning" }}
        mutate { replace => {"sr.description" => "A client exchanged version strings with the server and than disconnected" }}
      }
      if [code] == "UA" {
        mutate { replace => {"sr.summary" => "Unknown Authentication" }}
        mutate { replace => {"sr.description" => "The authentication method is not determinated or is unknown" }}
      }

      # UDM > Security Results 2
      mutate {
        merge => { "event1.idm.read_only_udm.security_result" => "sr" }
        on_error => "_merge_error"
      }
    }

     # UDM > Security Results > Description
    mutate {
      replace => { "code" => "%{inferences.1}"}
      on_error => "_inferences_1_not_found"
    }

    if ![_inferences_1_not_found] {
      if [code] == "ABP" {
        mutate { replace => {"sr3.summary" => "Client Authentication Bypass" }}
        mutate { replace => {"sr3.description" => "A client wasn't adhering to expectations of SSH either through server exploit or by the client and server switching to a protocol other than SSH after enctyption begins" }}
      }
      if [code] == "AFR" {
        mutate { replace => {"sr3.summary" => "SSH Agent Forwarding Requested" }}
        mutate { replace => {"sr3.description" => "Agent Forwarding is requested by tge Client" }}
      }
      if [code] == "APWA" {
        mutate { replace => {"sr3.summary" => "Automated Password Authentication" }}
        mutate { replace => {"sr3.description" => "The client authenticated with an automated password tool (like sshpass)" }}
      }
      if [code] == "AUTO" {
        mutate { replace => {"sr3.summary" => "Automated Interaction" }}
        mutate { replace => {"sr3.description" => "The client is a script automated utility and not driven by a user" }}
      }
      if [code] == "BAN" {
        mutate { replace => {"sr3.summary" => "Server Banner" }}
        mutate { replace => {"sr3.description" => "The server sent the client a pre-authentication banner, likely for legal reasons" }}
      }
      if [code] == "BF" {
        mutate { replace => {"sr3.summary" => "Client Brute Force Guessing" }}
        mutate { replace => {"sr3.description" => "A client made a number of authentication attempts that exceeded some configured, pre-connection threshold" }}
      }
      if [code] == "BFS" {
        mutate { replace => {"sr3.summary" => "Client Brute Force Success" }}
        mutate { replace => {"sr3.description" => "A client made a number of authentication attempts that exceeded some configured, pre-connection threshold" }}
      }
      if [code] == "CTS" {
        mutate { replace => {"sr3.summary" => "Client Trusted Server" }}
        mutate { replace => {"sr3.description" => "The client already has an entry in its known_hosts file for this server" }}
      }
      if [code] == "CUS" {
        mutate { replace => {"sr3.summary" => "Client Untrusted Server" }}
        mutate { replace => {"sr3.description" => "The client did not have an entry in its known_hosts file for this server" }}
      }
      if [code] == "IPWA" {
        mutate { replace => {"sr3.summary" => "Interactive Password Authentication" }}
        mutate { replace => {"sr3.description" => "The client interactively typed their password to authenticate" }}
      }
      if [code] == "KS" {
        mutate { replace => {"sr3.summary" => "Keystrokes" }}
        mutate { replace => {"sr3.description" => "An interactive session occurred in which the client set user-driven keystrokes to the server" }}
      }
      if [code] == "LFD" {
        mutate { replace => {"sr3.summary" => "Large Client File Donwload" }}
        mutate { replace => {"sr3.description" => "A file transfer occurred in which the server sent a sequence of bytes to the client" }}
      }
      if [code] == "LFU" {
        mutate { replace => {"sr3.summary" => "Large Client File Upload" }}
        mutate { replace => {"sr3.description" => "A file transfer occurred in which the client sent a sequence of bytes to the server. Large file are identified dynamically based on trains of MTU-sized packets" }}
      }
      if [code] == "MFA" {
        mutate { replace => {"sr3.summary" => "Multifactor Authentication" }}
        mutate { replace => {"sr3.description" => "The server required a second form of authentication (a code) after password or public key was accepted, and the client successfully provided it" }}
      }
      if [code] == "NA" {
        mutate { replace => {"sr3.summary" => "None Authentication" }}
        mutate { replace => {"sr3.description" => "The client successfully authenticated using the None method" }}
      }
      if [code] == "NRC" {
        mutate { replace => {"sr3.summary" => "No Remote Command" }}
        mutate { replace => {"sr3.description" => "The -N flag was used in SSH authentication" }}
      }
      if [code] == "PKA" {
        mutate { replace => {"sr3.summary" => "Public Key Authentication" }}
        mutate { replace => {"sr3.description" => "The client automatically authenticated using pubkey authentication" }}
      }
      if [code] == "RSI" {
        mutate { replace => {"sr3.summary" => "Reverse SSH Initiated" }}
        mutate { replace => {"sr3.description" => "The Reverse session is initiated from the server back to the client" }}
      }
      if [code] == "RSIA" {
        mutate { replace => {"sr3.summary" => "Reverse SSH Initiated Automated" }}
        mutate { replace => {"sr3.description" => "The inititation of the Reverse session happened very early in the packet stream, indicating automation" }}
      }
      if [code] == "RSK" {
        mutate { replace => {"sr3.summary" => "Reverse SSH Keystrokes" }}
        mutate { replace => {"sr3.description" => "Keystrokes are detected within the Reverse tunnel" }}
      }
      if [code] == "RSL" {
        mutate { replace => {"sr3.summary" => "Reverse SSH Logged In" }}
        mutate { replace => {"sr3.description" => "The Reverse Tunnel login has succeeded" }}
      }
      if [code] == "RSP" {
        mutate { replace => {"sr3.summary" => "Reverse SSH Providioned" }}
        mutate { replace => {"sr3.description" => "The client connected with -R flag, which provisions the port to be used for a Reverse Session set up at any future time" }}
      }
      if [code] == "SA" {
        mutate { replace => {"sr3.summary" => "Authentication Scanning" }}
        mutate { replace => {"sr3.description" => "The client scanned authentication method with the server and then disconnected" }}
      }
      if [code] == "SC" {
        mutate { replace => {"sr3.summary" => "Capabilities Scanning" }}
        mutate { replace => {"sr3.description" => "The client exchanged capabilities with the server and then disconnected" }}
      }
      if [code] == "SFD" {
        mutate { replace => {"sr3.summary" => "Small Client File Download" }}
        mutate { replace => {"sr3.description" => "A file transfer occurred in which the server sent a sequence of bytes to the client" }}
      }
      if [code] == "SFU" {
        mutate { replace => {"sr3.summary" => "Small Client File Upload" }}
        mutate { replace => {"sr3.description" => "A file transfer occurred in which the client sent a sequence of bytes to the server" }}
      }
      if [code] == "SP" {
        mutate { replace => {"sr3.summary" => "Other Scanning" }}
        mutate { replace => {"sr3.description" => "A client and server didn't exchange encrypted packets but the client wasn't a version or capabilities scanner" }}
      }
      if [code] == "SV" {
        mutate { replace => {"sr3.summary" => "Version Scanning" }}
        mutate { replace => {"sr3.description" => "A client exchanged version strings with the server and than disconnected" }}
      }
      if [code] == "UA" {
        mutate { replace => {"sr3.summary" => "Unknown Authentication" }}
        mutate { replace => {"sr3.description" => "The authentication method is not determinated or is unknown" }}
      }

      # UDM > Security Results 3
      mutate {
        merge => { "event1.idm.read_only_udm.security_result" => "sr3" }
        on_error => "_merge_error"
      }
    }

  }
  #


  # ----------------------------------------------------------------------
  # HTTP
  # - The logging model is to log request/response pairs and all relevant metadata together in a single record.
  # - https://docs.zeek.org/en/current/scripts/base/protocols/http/main.zeek.html

  if [_path] == "http" or [_path] == "http_red"  {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "NETWORK_HTTP" } }

    # UDM > Target > Hostname
    mutate {
      replace => {  "target_hostname" => "%{host}" }
      on_error => "_field_not_found"
    }

    # UDM > Target > URL
    mutate {
      replace => {  "target_url" => "%{uri}" }
      on_error => "_field_not_found"
    }

    # UDM > Target > HTTP Method
    mutate {
      replace => {  "network_http_method" => "%{method}" }
      on_error => "_field_not_found"
    }

    # UDM > Target > User Agent
    mutate {
      replace => {  "network_http_user_agent" => "%{user_agent}" }
      on_error => "_field_not_found"
    }

    # UDM > Network > Response Code
    mutate {
      convert => { "status_code" => "integer" }
      on_error => "_not_status_code"
    }

    if ![_not_status_code] {
      mutate {
        rename => { "status_code" => "network_http_response_code" }
        on_error => "_conversion_error"
      }
    }

    # UDM > Network > Received Bytes
    mutate {
      convert => { "response_body_len" => "uinteger" }
      on_error => "_not_received_bytes"
    }

    if ![_not_received_bytes] {
      mutate {
        rename => { "response_body_len" => "network_received_bytes" }
        on_error => "_conversion_error"
      }
    }

    # UDM > Network > Sent Bytes
    mutate {
      convert => { "request_body_len" => "uinteger" }
      on_error => "_not_sent_bytes"
    }

    if ![_not_received_bytes] {
      mutate {
        rename => { "request_body_len" => "network_sent_bytes" }
        on_error => "_conversion_error"
      }
    }

    # UDM > About > File > MimeType
    mutate {
      replace => { "about.file.mime_type" => "%{resp_mime_types.0}" }
      on_error => "_field_not_found"
    }

    # UDM > Security Results
    # - Base UDM security result based on HTTP Response Code
    # -  INFO ALLOW = 100 (Informational), 200 (Success), 300 (Redirection)
    # -  ERROR BLOCK = 400 (Client Error), 500 (Server Error)

    # - not all Corelight logs include a response code, check existence and mutate accordingly
    if ![_not_status_code] {

      if [network_http_response_code] > 99 and [network_http_response_code] < 400 {
        mutate {
          replace => {
            "security_result.severity" => "INFORMATIONAL"
            "sr_action" => "ALLOW"
          }
          on_error => "_field_not_set"
        }
      }

      if [network_http_response_code] > 399 and [network_http_response_code] < 600 {
        mutate {
          replace => {
            "security_result.severity" => "ERROR"
            "sr_action" => "BLOCK"
          }
          on_error => "_field_not_set"
        }
      }

    }

    # check if required udm validation fields for NETWORK_HTTP exist, if not set as NETWORK_CONNECTION
    if [network_http_method] == "" {
      mutate { replace => { "metadata_event_type"   => "NETWORK_CONNECTION" } }
    }

  }

  # ----------------------------------------------------------------------
  # suricata

  if [_path] == "suricata_corelight" {

    # UDM > Metadata > Event Type
    mutate { replace => { "metadata_event_type"   => "SCAN_NETWORK" } }

    # UDM > Principal
    mutate { replace => { "principal_ip"          => "%{id.orig_h}" } }
    mutate { replace => { "principal_port"        => "%{id.orig_p}" } }

    # UDM > Target
    mutate { replace => { "target_ip"             => "%{id.resp_h}" } }
    mutate { replace => { "target_port"           => "%{id.resp_p}" } }

    # UDM > Metadata
    mutate { replace => { "metadata_product_event_type" => "%{alert.signature}" } }
    mutate { replace => { "metadata_product_name"       => "Suricata" } }

    # UDM > Security Results
    mutate {
      convert => {
        "alert.severity"     => "string"
        "alert.signature_id" => "string"
      }
    }

    mutate {
      replace => {
        "security_result.summary"          => "%{alert.signature}"
        "security_result.threat_name"      => "%{alert.signature}"
        "security_result.severity"         => "INFORMATIONAL"
        "security_result.severity_details" => "%{alert.severity}"
        "sr_action"                        => "ALLOW"
        "sr_category"                      => "%{alert.category}"
        "security_result.rule_id"          => "%{alert.signature_id}"
      }
    }

    # only show sev 1 alerts in EI
    if [alert][severity] == "1" {
      # UDM > Alert
      mutate {
        replace => {
          "is_significant" => "true"
          "is_alert"       => "true"
        }
      }

      mutate {
        convert => {
          "is_significant" => "boolean"
          "is_alert"       => "boolean"
        }
      }
    }

  }
  #

  # ----------------------------------------------------------------------
  # suricata_eve

  if [_path] == "suricata_eve" {

    mutate {
        replace => {
          "app_proto" => ""
          "beat" => ""
          "dest_ip" => ""
          "dest_port" => ""
          "event_type" => ""
          "flow_id" => ""
          "host" => ""
          "in_iface" => ""
          "log" => ""
          "net_info" => ""
          "offset" => ""
          "proto" => ""
          "see_id" => ""
          "see_name" => ""
          "source" => ""
          "src_ip" => ""
          "src_port" => ""
          "tags" => ""
          "tenant" => ""
          "timestamp" => ""
          "type" => ""

          #http
          "http.hostname" => ""
          "http.http_content_type" => ""
          "http.http_method" => ""
          "http.http_port" => ""
          "http.http_user_agent" => ""
          "http.length" => ""
          "http.protocol" => ""
          "http.status" => "200"
          "http.url" => ""
          "http.user_agent" => ""
          "http.user_agent.build" => ""
          "http.user_agent.device" => ""
          "http.user_agent.name" => ""
          "http.user_agent.os" => ""
          "http.http_refer" => ""

          # dhcp
          "dhcp.assigned_ip" => ""
          "dhcp.client_mac" => ""
          "dhcp.dhcp_type" => ""
          "dhcp.hostname" => ""
          "dhcp.id" => ""
          "dhcp.renewal_time" => ""
          "dhcp.type" => ""

          # ssh
          "ssh.client.proto_version" => ""
          "ssh.client.software_version" => ""
          "ssh.server.proto_version" => ""
          "ssh.server.software_version" => ""

          # tls
          "tls.ja3s.string" => ""
          "tls.ja3s.hash" => ""
          "tls.ja3.string" => ""
          "tls.ja3.hash" => ""

          # dns
          "dns.type" => ""
          "dns.id" => ""
          "dns.version" => ""
          "dns.flags" => ""
          "dns.qr" => ""
          "dns.aa" => ""
          "dns.tc" => ""
          "dns.rd" => ""
          "dns.ra" => ""
          "dns.rrname" => ""
          "dns.rrtype" => ""
          "dns.rdata" => ""
          "dns.ttl" => ""
        }
    }

    # Parse JSON log
    json {
      on_error       => "not_json"
      source         => "raw_alert"
      array_function => "split_columns"
    }

    if [not_json] {
      drop{ tag => "TAG_MALFORMED_MESSAGE" }
    }

    # drop stats and poststats, no security value -  low level packet capture stat logs
    if [event_type] =~ "stats" {
        drop{ tag => "TAG_NO_SECURITY_VALUE" }
    }

    ################################
    # Global Values
    ################################

    # UDM > Metadata
    mutate {
      replace => {
        # default values
        "event2.idm.read_only_udm.metadata.event_type"          => "NETWORK_CONNECTION"
        "event2.idm.read_only_udm.metadata.vendor_name"         => "Suricata"
        "event2.idm.read_only_udm.metadata.product_name"        => "Eve"
        "event2.idm.read_only_udm.metadata.product_event_type"  => "%{event_type}"
      }
    }

    ################################
    # HTTP specific
    ################################
    #
    if [event_type] == "http" {

      mutate {
        replace => {
          "event2.idm.read_only_udm.metadata.event_type"          => "NETWORK_HTTP"
          "event2.idm.read_only_udm.target.hostname"              => "%{http.hostname}"
          "event2.idm.read_only_udm.network.application_protocol" => "HTTP"
          "event2.idm.read_only_udm.network.http.user_agent"      => "%{http.http_user_agent}"
          "event2.idm.read_only_udm.network.http.method"          => "%{http.http_method}"
        }
      }
      mutate {
        rename => {
          "http.length" => "event2.idm.read_only_udm.network.received_bytes"
          "http.status" => "event2.idm.read_only_udm.network.http.response_code"
        }
      }
      mutate {
        convert => {
          "event2.idm.read_only_udm.network.received_bytes"     => "uinteger"
          "event2.idm.read_only_udm.network.http.response_code" => "integer"
        }
      }

      if [dest_port] == 80 {
        mutate {
          replace => {
            "event2.idm.read_only_udm.target.url" => "http://%{http.hostname}%{http.url}"
          }
        }
      } else {
        mutate {
          convert => { "dest_port"     => "string" }
        }
        mutate {
          replace => { "dest_port_str" => "%{dest_port}" }
        }
        mutate {
          replace => { "event2.idm.read_only_udm.target.url" => "http://%{http.hostname}:%{dest_port_str}%{http.url}" }
        }
    }

    # HTTP referral is optional, so check if it's in the raw message
    if [http][http_refer] != "" {
        mutate {
          replace => {
            "event2.idm.read_only_udm.network.http.referral_url" => "%{http.http_refer}"
          }
        }
      }

    }
    # end http

    ################################
    # event_type 'dns' specific
    ################################
    #
    # only support for single dns suricata data, not grouped/detailed
    # grouped/detailed does work with this config, but the additional data is not parsed into the UDM
    # only 9 most common dns record types supported
    # only 9 most common dns response codes supported
    # full list here http://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml

    if [event_type] == "dns" {

      mutate {
        convert => {
          "dns.id" => "string"
        }
      }

      mutate {
        replace => {
          "event2.idm.read_only_udm.network.application_protocol" => "DNS"
          "event2.idm.read_only_udm.metadata.event_type"          => "NETWORK_DNS"
          "event2.idm.read_only_udm.network.dns.id"               => "%{dns.id}"
        }
      }

      if [dns][rrtype] == "A" {
        mutate {
          replace => {
            "dns.rrtype" => "1"
          }
        }
      }
      else if [dns][rrtype] == "AAAA" {
        mutate {
          replace => {
            "dns.rrtype" => "28"
          }
        }
      }
      else if [dns][rrtype] == "CNAME" {
        mutate {
          replace => {
            "dns.rrtype" => "5"
          }
        }
      }
      else if [dns][rrtype] == "MX" {
        mutate {
          replace => {
            "dns.rrtype" => "15"
          }
        }
      }
      else if [dns][rrtype] == "NS" {
        mutate {
          replace => {
            "dns.rrtype" => "2"
          }
        }
      }
      else if [dns][rrtype] == "PTR" {
        mutate {
          replace => {
            "dns.rrtype" => "12"
          }
        }
      }
      else if [dns][rrtype] == "SOA" {
        mutate {
          replace => {
            "dns.rrtype" => "6"
          }
        }
      }
      else if [dns][rrtype] == "SRV" {
        mutate {
          replace => {
            "dns.rrtype" => "33"
          }
        }
      }
      else if [dns][rrtype] == "TXT" {
        mutate {
          replace => {
            "dns.rrtype" => "16"
          }
        }
      }
      else {
        mutate {
          replace => {
            "dns.rrtype" => "0"
          }
        }
      }
      if [dns][type] == "query" {
        mutate {
          replace => {
            "event2.idm.read_only_udm.network.dns.response" => "false"
            "dns_question.name" => "%{dns.rrname}"
            "dns_question.type" => "%{dns.rrtype}"
          }
        }
        mutate {
          convert => {
              "dns_question.type" => "uinteger"
          }
        }
        mutate {
          merge => {
            "event2.idm.read_only_udm.network.dns.questions" => "dns_question"
          }
        }
      }
      if [dns][type] == "answer" {
        if [dns][rd] == "true" {
          mutate {
            replace => {
              "dns.rd" = "true"
            }
          }
        }
        else {
          mutate {
            replace => {
              "dns.rd" = "false"
            }
          }
        }
        if [dns][ra] == "true" {
          mutate {
            replace => {
              "dns.ra" = "true"
            }
          }
        }
        else {
          mutate {
            replace => {
              "dns.ra" = "false"
            }
          }
        }
        if [dns][aa] == "true" {
          mutate {
            replace => {
              "dns.aa" = "true"
            }
          }
        }
        else {
          mutate {
            replace => {
              "dns.aa" = "false"
            }
          }
        }
        if [dns][tc] == "true" {
          mutate {
            replace => {
              "dns.tc" = "true"
            }
          }
        }
        else {
          mutate {
            replace => {
              "dns.tc" = "false"
            }
          }
        }
        if [dns][rcode] == "NOERROR" {
          mutate {
            replace => {
              "dns.rcode" = "0"
            }
          }
        }
        else if [dns][rcode] == "FORMERR" {
          mutate {
            replace => {
              "dns.rcode" = "1"
            }
          }
        }
        else if [dns][rcode] == "SERVFAIL" {
          mutate {
            replace => {
              "dns.rcode" = "2"
            }
          }
        }
        else if [dns][rcode] == "NXDOMAIN" {
          mutate {
            replace => {
              "dns.rcode" = "3"
            }
          }
        }
        else if [dns][rcode] == "NOTIMP" {
          mutate {
            replace => {
              "dns.rcode" = "4"
            }
          }
        }
        else if [dns][rcode] == "REFUSED" {
          mutate {
            replace => {
              "dns.rcode" = "5"
            }
          }
        }
        else if [dns][rcode] == "YXDOMAIN" {
          mutate {
            replace => {
              "dns.rcode" = "6"
            }
          }
        }
        else if [dns][rcode] == "XRRSET" {
          mutate {
            replace => {
              "dns.rcode" = "7"
            }
          }
        }
        else if [dns][rcode] == "NOTAUTH" {
          mutate {
            replace => {
              "dns.rcode" = "8"
            }
          }
        }
        else if [dns][rcode] == "NOTZONE" {
          mutate {
            replace => {
              "dns.rcode" = "9"
            }
          }
        }
        else  {
          mutate {
            replace => {
              "dns.rcode" = "999"
            }
          }
        }
        mutate {
          replace => {
            "event2.idm.read_only_udm.network.dns.response" => "true"
            "dns_answers.resourcerecord.name" => "%{dns.rrname}"
            "dns_answers.resourcerecord.type" => "%{dns.rrtype}"
            "dns_answers.resourcerecord.data" => "%{dns.rdata}"
            "event2.idm.read_only_udm.network.dns.response_code"       => "%{dns.rcode}"
            "event2.idm.read_only_udm.network.dns.authoritative"       => "%{dns.aa}"
            "event2.idm.read_only_udm.network.dns.truncated"           => "%{dns.tc}"
            "event2.idm.read_only_udm.network.dns.recursion_desired"   => "%{dns.rd}"
            "event2.idm.read_only_udm.network.dns.recursion_available" => "%{dns.ra}"
            "dns_question.name" => "%{dns.rrname}"
            "dns_question.type" => "%{dns.rrtype}"
          }
        }
        # dns ttl isn't always present
        if [dns][ttl] != "" {
          mutate {
            replace => {
              "dns_answers.resourcerecord.ttl" => "%{dns.ttl}"
            }
          }
        }
        mutate {
          convert => {
              "event2.idm.read_only_udm.network.dns.recursion_desired"   => "boolean"
              "event2.idm.read_only_udm.network.dns.recursion_available" => "boolean"
              "event2.idm.read_only_udm.network.dns.truncated"           => "boolean"
              "event2.idm.read_only_udm.network.dns.authoritative"       => "boolean"
              "dns_answers.resourcerecord.type" => "uinteger"
              "dns_question.type"               => "uinteger"
              "event2.idm.read_only_udm.network.dns.response_code" => "uinteger"
              "dns_answers.resourcerecord.ttl" => "integer"
          }
        }
        mutate {
          merge => {
            "event2.idm.read_only_udm.network.dns.answers"   => "dns_answers.resourcerecord"
            "event2.idm.read_only_udm.network.dns.questions" => "dns_question"
          }
        }
      }
      mutate {
        convert => {
            "event2.idm.read_only_udm.network.dns.response" => "boolean"
            "event2.idm.read_only_udm.network.dns.id" => "uinteger"
        }
      }
    }

    ################################
    # event_type 'alert' specific
    ################################
    if [event_type] == "alert" {

      mutate {
        convert => {
          "alert.signature_id" => "string"
        }
      }

      mutate {
        replace => {
          "event2.idm.read_only_udm.metadata.event_type"       => "NETWORK_CONNECTION"
          "ev2_security_result.rule_id"   => "%{alert.signature_id}"
          "ev2_security_result.rule_name" => "%{alert.signature}"
          "ev2_security_result.summary"   => "%{alert.category}:%{alert.signature}"
        }
      }
      if [alert][category] == "Misc Attack" or [alert][category] == "Device Retrieving External IP Address Detected" or [alert][category] == "Potentially Bad Traffic" or [alert][category] == "Targeted Malicious Activity was Detected" or [alert][category] == "A suspicious string was detected" {
        mutate {
          replace => {
            "sr_category" => "NETWORK_MALICIOUS"
          }
        }
      }
      else if [alert][category] == "Not Suspicious Traffic" or [alert][category] == "Misc activity" or [alert][category] == "Unknown Traffic" {
        mutate {
          replace => {
            "sr_category" => "NETWORK_SUSPICIOUS"
          }
        }
      }
      else if [alert][category] == "Attempted User Privilege Gain" or [alert][category] == "Attempted Administrator Privilege Gain" or [alert][category] == "Web Application Attack" {
        mutate {
          replace => {
            "sr_category" => "EXPLOIT"
          }
        }
      }
      else if [alert][category] == "Potential Corporate Privacy Violation" {
        mutate {
          replace => {
            "sr_category" => "POLICY_VIOLATION"
          }
        }
      }
      else if [alert][category] == "A Network Trojan was detected" {
        mutate {
          replace => {
            "sr_category" => "NETWORK_COMMAND_AND_CONTROL"
          }
        }
      }
      else if [alert][category] == "Attempted Information Leak" {
        mutate {
          replace => {
            "sr_category" => "DATA_EXFILTRATION"
          }
        }
      }
      else if [alert][category] == "access to a potentially vulnerable web application" or [alert][category] == "Detection of a Network Scan" {
        mutate {
          replace => {
            "sr_category" => "NETWORK_RECON"
          }
        }
      }
      else {
        mutate {
          replace => {
            "sr_category" => "UNKNOWN_CATEGORY"
          }
        }
      }
      if [alert][severity] == 1 {
        mutate {
          replace => {
            "ev2_security_result.priority" => "HIGH_PRIORITY"
            "ev2_security_result.severity" => "HIGH"
          }
        }
      }
      else if [alert][severity] == 2 {
        mutate {
          replace => {
            "ev2_security_result.priority" => "MEDIUM_PRIORITY"
            "ev2_security_result.severity" => "MEDIUM"
          }
        }
      }
      else if [alert][severity] == 3 {
        mutate {
          replace => {
            "ev2_security_result.priority" => "LOW_PRIORITY"
            "ev2_security_result.severity" => "LOW"
          }
        }
      }
      else {
        mutate {
          replace => {
            "ev2_security_result.priority" => "UNKNOWN_PRIORITY"
            "ev2_security_result.severity" => "UNKNOWN_SEVERITY"
          }
        }
      }
      if [alert][action] == "allowed" {
        mutate {
          replace => {
            "sr_action" => "ALLOW"
          }
        }
      }
      else if [alert][action] == "drop" or [alert][action] == "reject" {
        mutate {
          replace => {
            "sr_action" => "BLOCK"
          }
        }
      }
      else {
        mutate {
          replace => {
            "sr_action" => "UNKNOWN_ACTION"
          }
        }
      }

      mutate {
        merge => {
          "ev2_security_result.category" => "sr_category"
        }
      }
      mutate {
        merge => {

          "ev2_security_result.action"   => "sr_action"
        }
      }
      mutate {
        merge => {
          "event2.idm.read_only_udm.security_result" => "ev2_security_result"
        }
      }

      mutate {
        replace => {
          "is_significant" => "true"
          "is_alert"       => "true"
        }
      }
      mutate {
        convert => {
          "is_significant" => "boolean"
          "is_alert"       => "boolean"
        }
      }
      mutate {
        rename => {
          "is_significant" => "event2.idm.is_significant"
          "is_alert"      =>  "event2.idm.is_alert"
        }
      }

    }
    # end alert

    ################################
    # event_type 'dhcp' specific
    ################################
    #
    if [event_type] == "dhcp" {
      mutate {
          replace => {
              "event2.idm.read_only_udm.network.application_protocol" => "DHCP"
              "event2.idm.read_only_udm.metadata.event_type" => "NETWORK_DHCP"
          }
      }
      # FIXME: do we care for anything else than ACK?
      if [dhcp][dhcp_type] != "" {
        mutate { uppercase => [ "dhcp.dhcp_type" ] }
        mutate { replace => {  "event2.idm.read_only_udm.network.dhcp.type" => "%{dhcp.dhcp_type}" }
        }
      }
      # opCode proto only supports these two options
      if [dhcp][type] =~ "reply|request" {
        mutate {
          uppercase => [ "dhcp.type" ]
        }
        mutate {
          replace => {  "event2.idm.read_only_udm.network.dhcp.opcode" => "BOOT%{dhcp.type}" }
        }
      }
      if [dhcp][assigned_ip] != "" {
        mutate { replace => {  "event2.idm.read_only_udm.network.dhcp.yiaddr" => "%{dhcp.assigned_ip}" } }
      }
      if [dhcp][client_mac] != "" {
        mutate { replace => {  "event2.idm.read_only_udm.network.dhcp.chaddr" => "%{dhcp.client_mac}" } }
      }
      if [dhcp][hostname] != "" {
        mutate { replace => {  "event2.idm.read_only_udm.network.dhcp.client_hostname" => "%{dhcp.hostname}" } }
      }

    }
    # end dhcp

    ################################
    # event_type 'tls' specific
    ################################
    #
    if [event_type] == "tls" {
      mutate {
        replace => {
          "event2.idm.read_only_udm.metadata.event_type"  => "NETWORK_CONNECTION"
        }
      }

      if [tls][ja3s][hash] != "" {
        mutate {
          replace => {
            "event2.idm.read_only_udm.network.tls.server.ja3s" =>  "%{tls.ja3s.hash}"
          }
        }
      }

      if [tls][ja3][hash] != "" {
        mutate {
          replace => {
            "event2.idm.read_only_udm.network.tls.client.ja3" =>  "%{tls.ja3.hash}"
          }
        }
      }

    }
    # end tls

    ################################
    # event_type 'flow' specific
    ################################

    if [event_type] == "flow" {
      mutate {
        replace => {
    "event2.idm.read_only_udm.metadata.event_type" => "NETWORK_FLOW"
        }
      }

      mutate {
        rename => {
          # FIXME: change order of convert first, then assign idm
          "flow.bytes_toclient" => "event2.idm.read_only_udm.network.received_bytes"
          "flow.bytes_toserver" => "event2.idm.read_only_udm.network.sent_bytes"
        }
      }

      mutate {
        convert => {
          "event2.idm.read_only_udm.network.received_bytes" => "uinteger"
          "event2.idm.read_only_udm.network.sent_bytes" => "uinteger"
        }
      }

    }
    # end flow

    #################################
    # General
    #################################

    date {
      match => ["timestamp", "ISO8601", "RFC3339", "yyyy-MM-dd'T'HH:mm:ss.SSSSSSZZZZ" ]
      #match => ["timestamp", "RFC3339" ]
      #match => ["timestamp", "yyyy-MM-dd'T'HH:mm:ss.SSSSSSZZZZ" ]
      #  timestamp variable is 2021-01-19T20:10:53.909411+0100
    }

    ### udm > principal
    if [src_ip] != ""  {
        mutate {
            merge => {
                "event2.idm.read_only_udm.principal.ip" => "src_ip"
            }
        }
    }
    if [src_port] != ""  {
        mutate {
            convert => {
                "src_port" => "integer"
            }
        }
        mutate {
            rename => {
                "src_port" => "event2.idm.read_only_udm.principal.port"
            }
        }
    }

    ### udm > target
    if [dest_ip] != ""  {
        mutate {
            merge => {
                "event2.idm.read_only_udm.target.ip" => "dest_ip"
            }
        }
    }
    if [dest_port] != ""  {
        mutate {
            convert => {
                "dest_port" => "integer"
            }
        }
        mutate {
            rename => {
                "dest_port" => "event2.idm.read_only_udm.target.port"
            }
        }
    }
    ### udm > network
    if [flow_id] != "" {
        mutate {
            convert => {
                "flow_id" => "string"
            }
        }
        mutate {
            rename => {
                "flow_id" => "event2.idm.read_only_udm.network.session_id"
            }
        }
    }
    # when submitting, the parser does not accept ipv6-icmp
    if [proto] == "IPv6-ICMP" { drop {} }
    if [proto] != "" {
        mutate {
            rename => {
                "proto" => "event2.idm.read_only_udm.network.ip_protocol"
            }
        }
    }

    # TODO(cmmartin): add SNMP, TLS to proto.  Find the master list of these
    if [app_proto] != "" and [app_proto] !~ "failed|snmp|tls"   {
        mutate {
            uppercase => [
                "app_proto"
            ]
        }
        mutate {
            rename => {
                "app_proto" => "event2.idm.read_only_udm.network.application_protocol"
            }
        }
    }

    # suricata > ssh
    # TODO(cmmartin): create FR to support SSH fields

    # udm > observer
    if [host] != "" {
        mutate {
            replace => {
                "event2.idm.read_only_udm.observer.hostname" => "%{host}"
            }
        }
    }

    if "event2.idm.read_only_udm.observer.network.application_protocol" == "" {
        mutate {
            replace => {
                "event2.idm.read_only_udm.observer.network.application_protocol" => "UNKNOWN_APPLICATION_PROTOCOL"
            }
        }
    }

    mutate {
      merge => { "@output" => "event2" }
    }


  }
  #

  # ----------------------------------------------------------------------
  # OUTPUT EVENT
  # - do not change below here, change things above ^^

  # UDM > Metadata > Vendor Name
  mutate {
    replace => { "event1.idm.read_only_udm.metadata.vendor_name"         => "%{metadata_vendor_name}" }
    on_error => "_field_not_set"
  }

  # UDM > Metadata > Product Name
  mutate {
    replace => { "event1.idm.read_only_udm.metadata.product_name"        => "%{metadata_product_name}" }
    on_error => "_field_not_set"
  }

  # UDM > Metadata > Event Type
  mutate {
    replace => { "event1.idm.read_only_udm.metadata.event_type"          => "%{metadata_event_type}"  }
    on_error => "_field_not_set"
  }

  # UDM > Metadata > Product Event Type
  mutate {
    replace => { "event1.idm.read_only_udm.metadata.product_event_type"  => "%{metadata_product_event_type}" }
    on_error => "_field_not_set"
  }

  # UDM > Metadata > Product Log ID
  mutate {
    replace => { "event1.idm.read_only_udm.metadata.product_log_id"      => "%{metadata_product_log_id}" }
    on_error => "_field_not_set"
  }

  # UDM > Metadata > Description
  mutate {
    replace => {
         "event1.idm.read_only_udm.metadata.description"         => "%{metadata_description}"
    }
    on_error => "_field_not_set"
  }

  # UDM > Metadata > Product Version
  mutate {
    replace => {
        "event1.idm.read_only_udm.metadata.product_version"         => "%{metadata_product_version}"
    }
    on_error => "_field_not_set"
  }

  # UDM > Metadata > Url Back To Product
  mutate {
    replace => { "event1.idm.read_only_udm.metadata.url_back_to_product"      => "%{metadata_url_back_to_product}" }
    on_error => "_field_not_set"
  }

  # UDM > Extension > Auth Type
  mutate {
    replace => {
         "event1.idm.read_only_udm.extensions.auth.type"         => "%{extensions_auth_type}"
    }
    on_error => "_field_not_set"
  }

  # UDM > Network > Direction
  mutate {
     replace => { "event1.idm.read_only_udm.network.direction" => "%{network_direction}" }
     on_error => "_field_not_set"
  }

  # UDM > Network > IP Protocol
  mutate {
     rename => { "network_ip_protocol" => "event1.idm.read_only_udm.network.ip_protocol" }
     on_error => "_field_not_set"
  }

  # UDM > Network > Application Protocol
  mutate {
     replace => { "event1.idm.read_only_udm.network.application_protocol" => "%{network_application_protocol}" }
     on_error => "_field_not_set"
  }

  # UDM > Network > Received Bytes
  mutate { rename => { "network_received_bytes" => "event1.idm.read_only_udm.network.received_bytes" } }

  # UDM > Network > Sent Bytes
  mutate { rename => { "network_sent_bytes" => "event1.idm.read_only_udm.network.sent_bytes" }  }

  # UDM > Network > Session Duration
  mutate {
     replace => { "event1.idm.read_only_udm.network.session_duration" => "%{network_session_duration}" }
     on_error => "_field_not_set"
  }

  # UDM > Network > DNS > Response Code
  # - 0 is default, i.e., NOERROR, and does not show in output
  mutate {
    rename => { "network_dns_response_code" => "event1.idm.read_only_udm.network.dns.response_code" }
    on_error => "_field_not_set"
  }

  # UDM > Network > EMAIL
  mutate {
    rename => { "network_email" => "event1.idm.read_only_udm.network.email" }
    on_error => "_field_not_set"
  }

  # UDM > Network > HTTP > User Agent
  mutate {
    rename => { "network_http_user_agent" => "event1.idm.read_only_udm.network.http.user_agent" }
    on_error => "_field_not_set"
  }

  # UDM > Network > HTTP > Response Code
  mutate {
    rename => { "network_http_response_code" => "event1.idm.read_only_udm.network.http.response_code" }
    on_error => "_field_not_set"
  }

  # UDM > Network > HTTP > Method
  mutate {
    rename => { "network_http_method" => "event1.idm.read_only_udm.network.http.method" }
    on_error => "_field_not_set"
  }

  # UDM > Network > Session ID
  mutate {
    replace => { "event1.idm.read_only_udm.network.session_id" => "%{network_session_id}" }
    on_error => "_field_not_set"
  }

  # UDM > Network > DHCP > Type
  mutate {
    rename => { "network_dhcp_type" => "event1.idm.read_only_udm.network.dhcp.type" }
    on_error => "_field_not_set"
  }

  # UDM > Network > DHCP > lease time seconds
  mutate {
    rename => { "network_dhcp_lease_time_seconds" => "event1.idm.read_only_udm.network.dhcp.lease_time_seconds" }
    on_error => "_field_not_set"
  }

  # UDM > Network > DHCP > Opcode
  mutate {
    rename => { "network_dhcp_opcode" => "event1.idm.read_only_udm.network.dhcp.opcode" }
    on_error => "_field_not_set"
  }

  # UDM > Principal > DHCP yiaddr
  mutate {
    rename => { "network_dhcp_yiaddr" => "event1.idm.read_only_udm.network.dhcp.yiaddr" }
    on_error => "_field_not_set"
  }

  # UDM > Principal > DHCP chaddr
  mutate {
    rename => { "network_dhcp_chaddr" => "event1.idm.read_only_udm.network.dhcp.chaddr" }
    on_error => "_field_not_set"
  }

  #
  # UDM > Principal > DHCP client_hostname
  mutate {
    rename => { "network_dhcp_client_hostname" => "event1.idm.read_only_udm.network.dhcp.client_hostname" }
    on_error => "_field_not_set"
  }

  # UDM > Principal > Username
  mutate {
    rename   => { "principal_username" => "event1.idm.read_only_udm.principal.user.userid" }
    on_error => "_field_not_set"
  }

  # UDM > Principal > User > Display Name
  mutate {
    rename   => { "principal_user_display_name" => "event1.idm.read_only_udm.principal.user.user_display_name" }
    on_error => "_field_not_set"
  }

  # UDM > Principal > Mac
  mutate {
     merge => { "event1.idm.read_only_udm.principal.mac" => "principal_mac" }
     on_error => "_merge_error"
  }

  # UDM > Principal > Hostname
  mutate {
    rename   => { "principal_hostname" => "event1.idm.read_only_udm.principal.hostname" }
    on_error => "_field_not_set"
  }

 # UDM > Principal > IP
  if [principal_ip] != "" {
    mutate { merge => { "event1.idm.read_only_udm.principal.ip" => "principal_ip" } }
  }


  # UDM > Principal > Port
  if [principal_port] != "" {
    mutate { convert => { "principal_port"  =>  "integer" }}
    mutate { rename => { "principal_port" => "event1.idm.read_only_udm.principal.port" } }
  }

  # UDM > Principal > Process > MD5
  mutate {
    rename => { "principal_process_md5" => "event1.idm.read_only_udm.principal.process.file.md5" }
    on_error => "_field_not_set"
  }

  # UDM > Principal > File > MD5
  #mutate {
  #  rename => { "principal_file_md5" => "event1.idm.read_only_udm.principal.file.md5" }
  #  on_error => "_field_not_set"
  #}

  # UDM > Principal > Process Command Line
  mutate {
    rename => { "principal_process_cmd" => "event1.idm.read_only_udm.principal.process.command_line"}
    on_error => "_field_not_set"
  }

  # UDM > Principal > Platform Version
  mutate {
    rename   => { "principal_platform_version" => "event1.idm.read_only_udm.principal.platform_version" }
    on_error => "_field_not_set"
  }

  # UDM > Principal > Resource Name
  mutate {
    rename => { "principal_resource_name" => "event1.idm.read_only_udm.principal.resource.name"}
    on_error => "_field_not_set"
  }

  # UDM > Principal > Resource Subtype
  mutate {
    rename => { "principal_resource_subtype" => "event1.idm.read_only_udm.principal.resource.resource_subtype"}
    on_error => "_field_not_set"
  }

  # UDM > Principal > Labels
  mutate {
    rename => { "principal_labels" => "event1.idm.read_only_udm.principal.labels" }
  }

  # UDM > Target > Labels
  mutate {
    rename => { "target_labels" => "event1.idm.read_only_udm.target.labels" }
  }

  # UDM > Target > Hostname
  mutate {
    rename   => { "target_hostname" => "event1.idm.read_only_udm.target.hostname" }
    on_error => "_field_not_set"
  }

  # UDM > Target > IP
  if [target_ip] != "" {
    mutate { merge => { "event1.idm.read_only_udm.target.ip" => "target_ip" } }
  }

  # UDM > Target > URL
  mutate {
    rename => { "target_url" => "event1.idm.read_only_udm.target.url" }
    on_error => "_field_not_set"
  }

  # UDM > Target > Port
  if [target_port] != "" {
    mutate { convert => { "target_port"  =>  "integer" } }
    mutate { rename => { "target_port" => "event1.idm.read_only_udm.target.port" } }
  }

  # UDM > Target > Username
  mutate {
    rename   => { "target_username" => "event1.idm.read_only_udm.target.user.userid" }
    on_error => "_field_not_set"
  }

  # UDM > Target > User > Display Name
  mutate {
    rename   => { "target_user_display_name" => "event1.idm.read_only_udm.target.user.user_display_name" }
    on_error => "_field_not_set"
  }

  # UDM > Target > Platform
  mutate {
    rename   => { "target_platform" => "event1.idm.read_only_udm.target.platform" }
    on_error => "_field_not_set"
  }

  # UDM > Target > Platform Version
  mutate {
    rename   => { "target_platform_version" => "event1.idm.read_only_udm.target.platform_version" }
    on_error => "_field_not_set"
  }

  # UDM > Target > Application
  mutate {
    rename   => { "target_application" => "event1.idm.read_only_udm.target.application" }
    on_error => "_field_not_set"
  }

  # UDM > Target > File > Full Path
  mutate {
    rename => { "target_file_full_path" => "event1.idm.read_only_udm.target.file.full_path" }
    on_error => "_field_not_set"
  }

  # UDM > Target > File > MD5
  mutate {
    rename => { "target_file_md5" => "event1.idm.read_only_udm.target.file.md5" }
    on_error => "_field_not_set"
  }

  # UDM > Target > File > SHA1
  mutate {
    rename => { "target_file_sha1" => "event1.idm.read_only_udm.target.file.sha1" }
    on_error => "_field_not_set"
  }

  # UDM > Target > File > SHA256
  mutate {
    rename => { "target_file_sha256" => "event1.idm.read_only_udm.target.file.sha256" }
    on_error => "_field_not_set"
  }

  # UDM > Target > File > Mime Type
  mutate {
    rename => { "target_file_mime_type" => "event1.idm.read_only_udm.target.file.mime_type" }
    on_error => "_field_not_set"
  }

  # UDM > Target > File > Size
  mutate {
    convert => { "target_file_size" => "uinteger" }
    on_error => "_conversion_error"
  }

  # UDM > Target > Process > MD5
  mutate {
    rename => { "target_process_md5" => "event1.idm.read_only_udm.target.process.file.md5" }
    on_error => "_field_not_set"
  }

  mutate {
    rename => { "target_file_size" => "event1.idm.read_only_udm.target.file.size" }
    on_error => "_field_not_set"
  }

  # UDM > Target > Resource Type
  mutate {
    rename => { "target_resource_type" => "event1.idm.read_only_udm.target.resource.type"}
    on_error => "_field_not_set"
  }

  # UDM > Target > Resource Name
  mutate {
    rename => { "target_resource_name" => "event1.idm.read_only_udm.target.resource.name"}
    on_error => "_field_not_set"
  }

  # UDM > Target > Resource Subtype
  mutate {
    rename => { "target_resource_subtype" => "event1.idm.read_only_udm.target.resource.resource_subtype"}
    on_error => "_field_not_set"
  }


  # UDM > Target > IP Protocol
  mutate {
    rename => { "target_ip_protocol" => "event1.idm.read_only_udm.target.ip_protocol"}
    on_error => "_field_not_set"
  }

  # UDM > Observer > Hostname
   mutate {
    replace => { "event1.idm.read_only_udm.observer.hostname" => "%{observer_hostname}" }
     on_error => "_field_not_set"
  }
  # UDM > Observer > Application
   mutate {
    replace => { "event1.idm.read_only_udm.observer.application" => "%{observer_application}" }
     on_error => "_field_not_set"
  }

  # UDM > About
  mutate {
    merge => {
      "event1.idm.read_only_udm.about" => "about"
    }
    on_error => "no_about"
  }

  # UDM > Alert
  mutate {
   rename => {
    "is_significant" => "event1.idm.is_significant"
    "is_alert"       => "event1.idm.is_alert"
   }
  }

  # UDM > Security Results > Action
  # - ENUM requires merge within its own mutate, ahead of final security result merge
  mutate {
    merge => { "security_result.action" => "sr_action" }
    on_error => "_merge_error"
  }

  mutate {
    merge => { "security_result.category_details" => "sr_category" }
    on_error => "_merge_error"
  }

  # UDM > Security Results
  mutate {
    merge => { "event1.idm.read_only_udm.security_result" => "security_result" }
    on_error => "_merge_error"
  }

  mutate {
     merge => { "@output" => "event1" }
  }

}
